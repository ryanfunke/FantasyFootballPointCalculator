# FantasyFootballPointCalculator
 This project was created as a submission for a course assignment, CNIT 25501. The original intention for creating the application was to allow users to verify the fantasy scoring of football players by inputting their performance statistics from a game and calculating a total, as errors in applications used to play fantasy football are quite common.  

The driver class in this program is Calculator.java.

# Project Abstract (Original Deliverable for Assignment)

The project created for my submission of this assignment was a Fantasy Football point calculator. The original intention for creating the application was to allow users to verify the fantasy scoring of football players by inputting their performance statistics from a game and calculating a total, as errors in applications used to play fantasy football are quite common. This was inspired by one of the labs we had completed previously in this course, and as a result the initial framework for the calculator was built upon some of the code from this lab. 

This calculator is started by the user and opens a graphical user interface which allows them to input the previously mentioned statistics from a football game, with input fields for each kind of statistic possible for an offensive player in American Football. Additionally, there is a menu within the graphical user interface to allow the user to select different scoring rulesets, as Fantasy Football leagues will implement different types of scoring for their players and thus impact the fantasy point total of a player. 

After the user inputs the statistics for a certain player into the GUI and receives a score in the GUI panel, a prompt opens in the console which asks for the name of the player associated with the statistics that were just entered into the program. The program will then create a new player for this entry or simply add the score to the player’s records, which are saved for future reference. Additionally, the player is then added to a “team”, as Fantasy Football operates on teams of players that combine for a user’s total score. These teams contain a roster which stores each player input by the user into the point calculator. 


# Project Description (Original Deliverable for Assignment)

The structure of the project relies upon 5 classes, and one interface. These classes are Calculator.java, Player.java, Team.java, SeasonRecord.java, and Ruleset.java. The interface is RecordInterface.java.

The most important part of the program starts with the Calculator.java class, which contains the needed components to initialize the GUI as well as acting as the “driver” file for the program. Function and method calls are all performed within this class, as it is the only class within the program to have public static void main(String args[]). This class starts by initializing the constructor for the class to create a new Calculator object, and then makes it visible. While running the constructor for the Calculator class, more constructors are ran to initialize objects of Ruleset.java, Player.java, and Team.java with default values. Afterwards, variables are initialized such as result (will be used to display the fantasy point total), an array of doubles called scores (which stores the scores calculated for a player to allow for multiple games recorded), error and displayLen which help to troubleshoot the Calculator GUI,  a string called disp to list the result of the calculator, MAX_DISPLAY_LEN and MAX_VALUE_EXLCUSIVE which are set to values of 5 and 1000.0 respectively, in order to reduce unnecessary data being shown and prevent unreasonable scores. The methods updateDisplay and toDisplayString use these variables to update the result bar of the calculator, through a series of if/else statements that format the data or detect if it is improperly entered.

Afterwards, the Calculator class contains methods to handle events occurring within the GUI, such as a system exit for the user choosing the “Exit” menu button, or a dialog window describing creator information and how to change the calculator ruleset. However, the most important method is the jButton23ActionPerformed (I couldn’t rename this as the Calculator.form file corrupted and would not let me manually edit the GUI anymore), which handles the actual calculation of the fantasy points. This method starts off by using a series of if statements to detect if the user input for each fantasy statistic in the GUI has valid input or not. If the specific formatted text field does not, then it is automatically set to 0 instead. Following this block of code within the method, next variables are created for each statistic and then filled with the user chosen value through the use of Double.parseDouble(++field++.getText()). This is then entered into the scores array initialized earlier in the program, where each variable is multiplied by a modifier that is stored within the ruleset object constructed earlier. This class creates an object with variables for a modifier to apply to each type of action a player can perform in football. There are also methods for choosing the rulesetSetting, which notes whether the user would like to calculate fantasy points for a Standard ruleset, Point Per Reception Ruleset, or 0.5 Point Per Reception. This setting is modified through the use of the menu button stored in the Calculator.java class, and uses a Switch to change the scoring modifiers within the setRuleset method. After the ruleset has been chosen and the scores need to be calculated, the modifiers mentioned before to apply to the parsed statistics are obtained from the ruleset object by methods for retrieving each modifier called get++Stat++Mod(). 

To explain further, the ruleset is modified by the user through the use of the GUI. This is executed by the user selecting the menu button labeled “Change Ruleset”, with each click changing the ruleset to the next setting. The ruleset setting is initially set to the “Standard” ruleset, and clicking the button shifts it to the “Point Per Reception” ruleset, with a second click changing it to “0.5 Point Per Reception” ruleset. If the user clicks this button once more, then the ruleset is changed back to the “Standard” ruleset and this loop can repeat once more. 

After this has been processed, the program will initialize a new variable called sum, which is ran through a for loop where each entry within the scores array is added and passed to the sum variable. Additionally, the program will print to the console the result of each score for the user to verify the program functions as intended. Once the total has been calculated, a Scanner object is created to ask the user for input about what the name of the target player is, which is stored by the program. If this name has been input previously, then the calculated sum is added to a variable entitled result, which is then stored in the SeasonRecord object through the methods in the Player and SeasonRecord class named addScore. Afterwards, another method is ran called viewStats, which lists the player’s name and then each of the fantasy scores calculated by the program for them. 

Should the player not already exist in the records, a prompt will be shown which allows the user the option to add them to their fantasy team or not. If the user opts to add the player to their fantasy team, the player object is added to an array within the Team class that stores them through the method addToRoster. The display is then updated within the GUI to show the result of the calculated fantasy points for that player.

To conclude, I’ll discuss the development of the program and the project in its entirety. As I have mentioned in my presentation, the amount of work that I took on working alone was far more than I had expected, which meant feature creep was difficult to deal with and I found myself having tunnel vision at certain points. 

However, the overall structure of the project shifted quite a bit throughout development. My initial program had a few different classes and the GUI looked completely different than the final product. This was due to the fact that the statistics input was purely buttons in the initial design, whereas the final product allowed the user to input numbers specifically with text to streamline data processing and input for the user. On top of this, the storing of data was far different and the methods to access and store player fantasy statistics performed different functions. After struggling to keep data persistent, I opted to store results of the Fantasy Points calculator in arrays and allow the user to specify a player and fantasy team to make sorting data and retaining it more intuitive. 

Additionally, inheritance was used to extend functionality of classes instead of creating a hierarchy for designing objects. This is seen by the Calculator class extending JFrame, or the player class extending the Object class to eliminate errors with initializing constructors and allowing the class to pass data from Player to SeasonRecord. Meanwhile, RecordInterface.java was the interface I implemented to help provide a blueprint for my SeasonRecord class. The interface was one of the first classes I wrote, while SeasonRecord was the last due to concerns about how I would implement the program. Therefore, the RecordInterface provides my SeasonRecord with a blueprint for the methods I wanted to implement – addScore and getScores – without requiring me to decide how I want to implement them immediately. 

Overall, the project was a great learning experience and will provide me with a future point of comparison for my Java development skills. Quite a bit of the program has room to expand functionality or implement other features, but these were excluded to finish the product by the assignment deadline and therefore leaves room for me to experiment with these ideas in the future.
